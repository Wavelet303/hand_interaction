#include <boost/thread/thread.hpp>
#include <boost/thread/mutex.hpp>
#include <boost/thread/condition.hpp>
#include <Eigen/StdVector>
#include <ros/ros.h>
#include <body_msgs/Skeletons.h>
#include <sensor_msgs/PointCloud.h>
#include <body_msgs/Hands.h>
#include <sensor_msgs/point_cloud_conversion.h>
#include <pcl_tools/pcl_utils.h>
//#include <pcl_tools/segfast.hpp>
#include "pcl/common/transform.hpp"
#include "pcl/io/pcd_io.h"
#include "pcl/point_types.h"
#include <pcl/ModelCoefficients.h>

#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>

#include <sstream>
#include <iostream>
#include <fstream>
#include <cstdlib>

using namespace std;

/*void getTransFromUnitVectorsZY(const Eigen::Vector3f& z_axis, const Eigen::Vector3f& y_direction, Eigen::Affine3f& transformation)
{
   Eigen::Vector3f tmp0 = (z_axis.cross(y_direction)).normalized();
   Eigen::Vector3f tmp1 = (z_axis.cross(tmp0)).normalized();
   Eigen::Vector3f tmp2 = z_axis.normalized();
   
   transformation(0,0)=tmp0[0]; transformation(0,1)=tmp0[1]; transformation(0,2)=tmp0[2]; transformation(0,3)=0.0f;
   transformation(1,0)=tmp1[0]; transformation(1,1)=tmp1[1]; transformation(1,2)=tmp1[2]; transformation(1,3)=0.0f;
   transformation(2,0)=tmp2[0]; transformation(2,1)=tmp2[1]; transformation(2,2)=tmp2[2]; transformation(2,3)=0.0f;
   transformation(3,0)=0.0f;    transformation(3,1)=0.0f;    transformation(3,2)=0.0f;    transformation(3,3)=1.0f;
}


void getTransformationFromTwoUnitVectors(const Eigen::Vector3f& y_direction, const Eigen::Vector3f& z_axis, Eigen::Affine3f& transformation)
{
   getTransFromUnitVectorsZY(z_axis, y_direction, transformation);
}


void getTransformationFromTwoUnitVectorsAndOrigin(const Eigen::Vector3f& y_direction, const Eigen::Vector3f& z_axis,
                                                   const Eigen::Vector3f& origin, Eigen::Affine3f& transformation)
 {
  getTransformationFromTwoUnitVectors(y_direction, z_axis, transformation);
  Eigen::Vector3f translation = transformation*origin;
  transformation(0,3)=-translation[0];  transformation(1,3)=-translation[1];  transformation(2,3)=-translation[2];
}

*/
int main(int argc, char ** argv)
{
  //ros::init(argc, argv, "test");
  int classs;
  cout << "Input class label( 1 / 0 ): " ;
  cin >> classs;
  
  
  system("ls *pcd >> filelist");
  system("mkdir converted");
  system("mkdir histogram");
  
  pcl::PointCloud<pcl::PointXYZ> cloud, output;
  EIGEN_ALIGN16 Eigen::Vector3f eigen_values;
  EIGEN_ALIGN16 Eigen::Matrix3f eigen_vectors;
  Eigen::Matrix3f cov;
  Eigen::Vector4f centroid, direction,armvector;
  
  Eigen::Vector3f z_axis, y_axis, x_axis, origin;
  Eigen::Affine3f transformation;
   
  std::stringstream filename;
  int count = 0;
  ifstream in("filelist");
  ofstream out("trainingdata.txt");
  while ( ! in.eof() )
  {
     char name[256];
    in.getline( name, 256 );

    pcl::io::loadPCDFile( name, cloud );

    pcl::compute3DCentroid (cloud, centroid);
    pcl::computeCovarianceMatrixNormalized(cloud,centroid,cov);
    pcl::eigen33 (cov, eigen_vectors, eigen_values);

   
    z_axis[0] = eigen_vectors( 0, 2);
    z_axis[1] = eigen_vectors( 1, 2);
    z_axis[2] = eigen_vectors( 2, 2);
    
    y_axis[0] = eigen_vectors( 0, 0);
    y_axis[1] = eigen_vectors( 1, 0);
    y_axis[2] = eigen_vectors( 2, 0);
    
    x_axis[0] = eigen_vectors( 0, 1);
    x_axis[1] = eigen_vectors( 1, 1);
    x_axis[2] = eigen_vectors( 2, 1);

    

    /* z_axis[0] = 0;//eigen_vectors( 0, 2);
    z_axis[1] = 0;//eigen_vectors( 1, 2);
    z_axis[2] = 1;//eigen_vectors( 2, 2);
    
    y_axis[0] = 0;//eigen_vectors( 0, 0);
    y_axis[1] = 1;//eigen_vectors( 1, 0);
    y_axis[2] = 0;//eigen_vectors( 2, 0);
    */
    

    origin [ 0 ] = centroid[0];
    origin [ 1 ] = centroid[1];
    origin [ 2 ] = centroid[2];
   

   pcl::getTransformationFromTwoUnitVectorsAndOrigin(y_axis, z_axis, origin, transformation);

   pcl::getTransformedPointCloud (cloud, transformation, output);

   pcl::PointXYZ min_pt, max_pt;

   pcl::getMinMax3D( output, min_pt, max_pt);

   
   
   
    //pcl::demeanPointCloud(cloud, centroid, output);
    filename.str("");
    
    filename << "converted/" << setfill('0') << setw(8) << count << ".pcd";
    pcl::io::savePCDFileASCII( filename.str().c_str(), output);
    cout << "Wrote : "  << filename.str() << endl;
    cout << " Max : " << max_pt.z << " " << max_pt.y << " " << max_pt.x << endl;
    cout << " Min : " << min_pt.z << " " << min_pt.y << " " << min_pt.x << endl;
    
    
    
    float r = ( max_pt.y - min_pt.y )* ( max_pt.y - min_pt.y) +  ( min_pt.x - max_pt.x) * ( min_pt.x - max_pt.x )  ;
    r /= 4;

    
    float offset_r = r / 5;
    origin[2] = min_pt.z;
    
    float offset_z = (max_pt.z - min_pt.z) / 6;
    const double PI = 3.141592;
    float offset_a = PI / 4;

    float histogram[280];
    for ( int i = 0; i < 280; i++ )
      
      {
	histogram[i] = 0.0;
	//	cout << histogram[i];
      }
     for ( int i = 0; i < output.points.size(); i++ )
      {
	int zz = floor (( output.points[i].z - origin[2] ) / offset_z);
	int pp = (int) (( output.points[i].y * output.points[i].y  + output.points[i].x * output.points[i].x ) / offset_r );
	int aa = (int) (( PI + atan2(output.points[i].y, output.points[i].x)) / offset_a );

        int index = zz * 40 + pp * 8 + aa;
	//if ( index < 0 || index > 239 ) cout << "Out of range!!" << " " << zz << " " << pp << " " << aa << endl;
	
	histogram[ index  ] += 1.0;

      }
     
     for ( int i = 0; i < 280; i++ )
    {
      histogram[i] /= (float) output.points.size();
      // tcout << histogram[i] << endl;
    }
    
    out << classs;
   
    for ( int i = 0; i < 280; i++ )
    {
	out << " " << i+1 << ":" <<  histogram[i];
    }
    
    out << endl;

     // getTransFromUnitVectorsZY (z_axis, y_axis, transformation);
   
   
    count++;
    }

    out.close();
  return 0;
}
